\section{Usage sample mining}
\label{sec:usage_mining}

\begin{figure*}
	\begin{minipage}{\linewidth}
		\newcommand\textlowlight[1]{\textcolor{gray}{#1}}
		\newcommand\texthighlight[1]{\textcolor{accent1}{#1}}
		\begin{center}
			\begin{subfigure}[t]{.32\linewidth}
				\input{sections/5_usage_mining/patterns/CallExpression}
			\end{subfigure}
			\hfill
			\begin{subfigure}[t]{.32\linewidth}
				\input{sections/5_usage_mining/patterns/PropertyAccessExpression}
			\end{subfigure}
			\hfill
			\begin{subfigure}[t]{.32\linewidth}
				\input{sections/5_usage_mining/patterns/JsxOpeningElement}
			\end{subfigure}

			\caption{AST patterns for example JavaScript/TypeScript expressions.
				The \texthighlight{highlighted} node contains the link to the declaration of the referenced identifier.
			}
			\label{fig:usage_mining/patterns}
		\end{center}
	\end{minipage}
\end{figure*}

Having downloaded the selected downstream dependency repositories, we can proceed to extract usage samples for the target package from each dependency repository.
Our goal is to collect fine-grained source code excerpts that reference single identifiers exposed by the target package.

\begin{algorithm}[b]
	\caption{Extraction of usage samples.}\label{alg:usage_mining}

	\KwIn{\\\Indp
		$\mli{pkg}$: target package \\
		$\mli{dependencies}$: downstream dependencies}
	\KwOut{usage samples (set of strings)}
	\;
	\For{$\mli{dep} \in \mli{dependencies}$}{
		$\mli{asf} \gets \mtx{parse}(\mli{dep} \cup \mli{pkg})$\;
	  	$\mtx{annotate\_types}(\mli{asf})$\;
		\For{$\mli{ast} \in \mli{asf}$}{
			\For{$\mli{node} \in \mli{dfs}(\mli{ast})$}{
				\For{$\mli{pattern} \in \mli{patterns}$}{
					\If{$\mli{pattern}.\mtx{matches}(\mli{node}) \wedge \mli{pkg}.\mtx{declares}(\mli{pattern}.\mtx{getType}(\mli{node}))$}{
						\kwYield{$\mli{node}.\mtx{text}$}
					}
				}
			}
		}
	}
\end{algorithm}

To do so, we start by parsing the source code of every dependency repository as well as the source code of the target package each into a separate abstract syntax forest (ASF, i.e., a set of ASTs).

In a second step, we perform a static type analysis against each dependency ASF together with the target package's ASF.
The results of the type analysis are attached to the ASF so that every identifier is annotated with a type symbol that links to the declaration of the type for the identifier.
For instance, after this step, every variable node will contain a link to the assignment node of this variable, and every function call expression will contain a link to the definition of this function.
The operating principle of this type analysis depends on the kind of programming language; i.e., in statically typed languages, type symbols can usually be retrieved from the declaration of an identifier, whereas in dynamically typed languages, a control flow analysis will be required to identify the origin of every identifier's type.

In the final step, from each ASF, we collect all nodes whose type is declared in the target package.
To identify these links, we define a set of language-specific patterns for AST subtrees that constitute a usage expression.
In particular, each of these patterns expects a node containing a link to an identifier declaration (see \cref{fig:usage_mining/patterns}).

The complete procedure is displayed in \cref{alg:usage_mining}.
