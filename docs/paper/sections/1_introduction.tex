\section{Introduction}
\label{sec:introduction}

Open Source software (OSS) solutions have become more and more and important during the last decades.
Especially, this trend has been experiencing an additional updraft due to the ongoing spreading of OSS platforms such as GitHub or GitLab.
Open-source development offers many advantages as opposed to traditional closed-source development, including large numbers of volunteer contributions from the open-source community, increased transparency effects in security-related domains, and a high potential for reusing solutions.
These solutions are usually organized as \emph{packages} each of which attempts to solve an isolated problem and provide a generic interface.
Most commonly, packages are developed in a \emph{code repository} that is managed using a \emph{development platform} (such a \emph{GitHub}\footnote{\url{https://github.com/}}, \emph{GitLab}\footnote{\url{https://gitlab.com/}}, or \emph{Bitbucket}\footnote{\url{https://bitbucket.com/}}) and deployed to a \emph{package repository} using a \emph{package manager} (such as \emph{PyPI}\footnote{\url{https://pypi.org/}} using \emph{pip}\footnote{\url{https://pip.pypa.io/}} for the Python programming language, the \emph{npm registry}\footnote{\url{https://www.npmjs.com/}} for JavaScript/TypeScript, or the \emph{NuGet Gallery}\footnote{\url{https://www.nuget.org/}} for languages from the .NET ecosystem).
Other solutions or packages can then \emph{depend} on existing packages.
These dependency relations form a large directed graph that connects major parts of the software world for each popular programming language ecosystem.

Despite this connectedness by design, however, the development process of many packages is still characterized by an isolated approach:
While OSS developers commonly submit tickets to or contribute patches against \emph{upstream repositories} that they depend on to solve subproblems, the reverse direction of these edges -- called \emph{downstream dependencies} -- is often neglected by package developers when they extend, restructure, or refactor their solutions.
This knowledge deficit can cause a wide range of alignment issues, including poorly suited interfaces \citep{piccioni2013empirical}, unidentified defects \citep{wong2017more}, and compatibility problems \citep{bogart2015breaks}.
Eventually, all these issues impair the capabilities of the global OSS community to build and support high-quality products.
In the following, downstream dependencies will also be referred to shortly as \emph{dependencies}.

To tackle these concerns, in this paper, we propose an approach to extract API usage samples from downstream dependency repositories of individual packages in order to support package developers in surveying usages of their solutions.
We further make these data directly available to package developers by integrating them into an integrated development environment (IDE).

The rest of this paper is organized as follows:
In \cref{sec:related_work}, we give a summary of existing approaches in this field.
In \cref{sec:framework}, we outline the overall conditions and the general approach for our solution to mining downstream dependencies.
In \cref{sec:dependency_collection} and \cref{sec:usage_mining}, we explain our approach for collecting downstream dependency repositories resp. mining usage data from these repositories in detail.
In \cref{sec:implementation}, we describe an implementation of the proposed approach and our design decisions for displaying usage samples to the user.
In \cref{sec:evaluation}, we examine the fitness of our data mining approach and the usability of the display solution.
